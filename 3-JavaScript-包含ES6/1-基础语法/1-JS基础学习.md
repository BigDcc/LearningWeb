# 1. JavaScript简介

[TOC]

## 1 JavaScript简介

### 1.1 JavaScript简介

#### 1.1.1 JavaScript的诞生

　　JavaScript诞生于1995年，由布兰登-艾奇创造，起初的主要用途是处理以前由服务器端语言负责的一些输入验证操作，解决了人们在操作页面时，漫长的服务器端校验回传所浪费的时间，如今，JavaScript的用途早已不再局限于简单的数据验证，而是具备了与浏览器窗口以及其内容等几乎所有方面交互的能力。

#### 1.1.2 JS与ES

　　由于 JavaScript 1.0 很受欢迎，Netscape 在 Netscape Navigator 3 中又发布了 JavaScript 1.1 版本。不久，微软在 Internet Explorer 3 中也加入了脚本编程功能。为了避免与 Netscape 的 JavaScript 产生纠纷，微软特意将其命名为 JScript。1997 年，欧洲计算机制造商协会（ECMA）以 JavaScript 1.1 为基础制订了脚本语言标准——ECMA-262，并命名为 ECMAScript。1998 年，国际标准化组织和国际电工委员会（ISO/IEC）采用了 ECMAScript 标准（即 ISO/IEC-16262）。自此，浏览器厂商就以 ECMAScript 作为各自 JavaScript 实现的规范标准。简单概括，ECMAScript 是 JavaScript 语言的规范标准，JavaScript 是 ECMAScript 的一种实现。

　　Web 浏览器只是 ECMAScript 实现的宿主环境之一。宿主环境不仅提供基本的 ECMAScript 实现，同时也会提供各种扩展功能(DOM和BOM)。ECMAScript 是 JavaScript 的标准，但它并不等同于 JavaScript，也不是唯一被标准化的规范。

#### 1.1.3 JavaScript如今的含义

　　实际上，现在我们所指的 JavaScript 实现由以下 3 个不同部分组成：

- 核心（ECMAScript）：语言核心部分。
- 文档对象模型（Document Object Model，DOM）：网页文档操作标准。
- 浏览器对象模型（BOM）：客户端和浏览器窗口操作基础。

![javascript组成](./res/000.png)

#### 1.1.4 JS的能力和它的未来

- JavaScript是一款纯正的Web编程语言，让你能够给网页添加行为；

- JavaScript是最流行的编程语言之一，所有现代浏览器（和大多数古老的浏览器）都支持它；

- 当今的js已经被嵌入除浏览器外的其他众多环境中；

#### 1.1.5 浏览器中html,css,js的协同关系

![网页三剑客](./res/001.png)

#### 1.1.6  引入js代码

　　JavaScript程序不能够独立运行，只能在宿主环境中执行。一般情况下可以把 JavaScript 代码放在网页中，借助浏览器环境来运行（这是因为浏览器中包含js的解释器，如chrome浏览器使用的js引擎称为V8）

　　通过HTML标签中的`<script>`标签可以引入js代码(包含两种方式):

　　**1. 内嵌js代码：**

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <script type="text/javascript">
        alert("hello js!")
    </script>
</head>
<body>
    hello
</body>
</html>
```

　　**2. 从外部引入js代码：**

```javascript
// hello.js
alert("hello js")
```

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <script type="text/javascript" src="./hello.js"></script>
</head>
<body>
    hello
</body>
</html>
```

　　上述过程可概括成以下图示：

![html引用js代码](./res/002.png)

> **注意事项**

> - 不能在引用JavaScript文件的同时内嵌JavaScript代码，即script标签在使用src属性后，不能在标签中包含js代码，因为浏览器不会再去解析其中的代码；
> - `<script>`标签可以存放在`<body>`或者`<head>`中，最好是存放在`<body>`中的结尾处，这样不影响用户加载网页内容，否则可能会导致浏览器在下载js代码时，造成页面显示的延迟；
> - type属性以及其值text/javascript，不是必须设置的，现代浏览器默认 `<script>` 标签的脚本类型为 JavaScript，因此可以省略 type 属性；如果考虑到兼容早期版本浏览器，则需要设置 type 属性；
> - html文档中，script标签不能在开始标签中闭合，引入的外部文件的后缀名不是必须的，为其他语言动态生成js代码提供了可能性，不过省略的前提是保证服务器能正确的返回MIME类型；

#### 1.1.7 js中的输入输出

　　js核心语法没有提供输入输出api，输入输出由宿主环境提供。

1. 浏览器提供了一个内置函数，可以用来获取用户输入；这个函数就是prompt;

```js
var name = prompt("Enter your name:");
```

2.  浏览器提供的输出方法，主要是以下四种；

```js
// 弹出警告框
window.alert()
// 将内容写到 HTML 文档中直接写入 HTML 输出流,只能在 HTML 输出中使用 document.write。如果在文档加载后使用该方法，会覆盖整个文档
document.write()
// HTML-DOM中独有的innerHTML, 将内容写到HTML中
innerHTML
// 写入到浏览器的控制台
console.log()
```

#### 1.1.8 js中的一些语法注意点

1. **大括号与分号**

   - 与python通过缩进和冒号来识别代码块不同，js中采用`{}`和`;`来区分代码块和语句，虽然实际操作中`;`不是必须的，但是最佳的实践是加上他，这样可以在文件中去除多余的空格来减少js的体积，以及减少解释器智能添加`;`的性能损耗，并增加代码性能。

2. **代码块**

   - 从语法上说，代码块是放在花括号内的一组语句，可以只包含一条语句，也可以包含任意数量的语句。代码块中的所有语句被视为一个整体，要么都执行，要么都不执行。

3. **分隔符**

   - 在JavaScript中，分隔符不被解析，主要用来分隔各种记号，如标识符、关键字、直接量等信息。 在 JavaScript 脚本中，常用分隔符来格式化代码，分隔符（空白符）就是各种不可见字符的集合，如空格（\u0020）、水平制表符（\u0009）、垂直制表符（\u000B）、换页符（\u000C）、不中断空白（\u00A0）、字节序标记（\uFEFF）、换行符（\u000A）、 回车符（\u000D）、行分隔符（\u2028）、段分隔符（\u2029）等。
   - 分隔符虽然无实际意义，但是在脚本中却不能缺少。如果在标识符与关键字之间不使用分隔符分隔，JavaScript 就会抛出异常;

4. **标识符**

   - 标识符被用于语句，变量，参数，属性名，运算符和标记，ES中命名规范如下所示：

     - ECMAScript的标识符区分大小写， test和Test是两个不同的标识符；

     - 不能以数字开头，字符由字母，数字，下划线，美元符组成（除非有充分的理由，否则不要使用以_ 或**$**打头的变量名，它们通常被js库所占用。）;

     - 标识符最好采用驼峰大小写的方式进行命名，如`sayHello`,当然也可以使用下划线的方式命名（Unix风格）；

     - 不使用任何内置关键字和保留字；

     - 除了第一个字符外，其他位置可以使用 Unicode 字符。一般建议仅使用 ASCII 编码的字母，不建议使用双字节的字符（如汉字等）;

#### 1.1.9 注释

　　注释应该优先用来提高程序的可读性，js提供以下两种注释方式：

```javascript
// 单行注释

/*
 *	块注释（第一行和尾行的写法是必须的，中间的行首以星号开始不是必须的，这样写主要是提高可读性）
 *  与python等语言一样，解释器不会执行注释中的内容
 */
```

> **注意事项：**

> - 应该尽量避免在代码中出现块注释，因为块注释的语法字符可能会出现在正则表达式字面量中，导致代码不安全；
>
> ```js
> /*
> 	var rm_a = /a*/.match(s);
> */
> ```

### 1.2 js中的一些注意事项

#### 1.2.1 noscript标签的应用

　　当浏览器出现以下情况时，我们可以使用noscipt标签显示内容。

- 浏览器不支持js脚本；
- 浏览器支持脚本，但脚本被禁用；

```html
<body>
    <noscript>
        <p>该网页需要启用js</p>
    </noscript>
    <h1 title="标题">你好</h1>
</body>
```

　　chrome浏览器可以在设置 -> 隐私设置与安全性 -> 网站设置 -> 内容 -> JavaScript中启用和禁止脚本。

#### 1.2.2 严格模式

　　ES5中引入严格模式的概念，在严格模式下ES3中的一些不确定的行为将得到处理，对某些不安全的操作也会抛出错误。如在ES3中的函数中，不声明一个变量直接使用一个变量进行赋值操作时，就会引发异常（引发ReferenceError错误）。

```js
"use strict"; // 整个脚本中启用严格模式，可以在脚本的开头进行声明，这个声明其实是个编译指示

function sayHello() {
    "use strict";  // 在函数中使用严格模式，放在函数的顶层即可，严格模式只会在该函数中生效
    console.log("hello world!");
}
```

### 1.3 变量

#### 1.3.1 定义变量

　　js的变量是松散类型（松散类型的意思是可以用来保存任何类型的数据），在生命周期内可以随时改变，定义变量使用关键字`var`声明;

```javascript
// 先声明在赋值
var name;
name = "achui";

// 声明和赋值同时进行
var age = 18;

// 声明后,在使用前没有赋值
var gender; // 变量在声明后没有赋值，保存一个默认的值undefined

// 给一个未声明的变量直接赋值，会导致该变量，为全局变量
// 这种情况在严格模式下会抛出ReferenceError错误
idCard = 1231231231312

// 定义多变量
var name = "achui",  // 换行可以提高可读性
    age = 18,
    gender = "women";
```

#### 1.3.2 变量的作用域

　　变量的定义位置决定了其作用域，即变量在代码的哪些地方可见，哪些地方不可见;

　　变量的作用域分两种：全局（global）和局部（local）如果变量是在函数外声明的，它就是全局变量；如果变量是在函数中声明的，它就是局部变量。使用未声明的变量时，它将自动被视为全局变量，即便他在函数中出现；

```js
// test.js

var name;  // 声明一个全局变量

function sayHello() {
    var name; // 声明一个局部变量
    age = 18;  // 在函数内定义了一个全局变量
}
```

> **注意事项**

> 1. **多个js文件被加载时，作用域怎么划分**
>    - 只有一个全局作用域，因此加载的每个文件看到的变量都相同（它们创建的全局变量位于同一个空间内）。因此，避免使用的变量发生冲突（并尽可能少用甚至不用全局变量）至关重要。
> 2. **全局变量和局部变量重名时，使用哪个变量**
>    - 如在函数内部使用时，函数内部的被局部变量将“遮住”（shadow）全局变量，即就近原则。

#### 1.3.3 变量的声明周期

　　全局变量的寿命与网页一样长。全局变量在JavaScript代码加载到网页之后降生，并在网页消失后死去。局部变量通常在函数结束时消失。局部变量是在函数被调用后创建的，并一直活到函数返回（无论函数是否返回值）。然而，在局部变量的大限到来前，可从函数返回它们的值。

#### 1.3.4 变量声明的最佳实践

- 在js文件开头声明全局变量， 在函数开头声明局部变量；
- 变量的命名应准守标识符规范；

- 将i用作迭代变量的做法历史悠久。这种约定始于空间有限的年代，也算是一种命名规范；

#### 1.3.4 变量提升

通常JS引擎会在正式执行之前先进行一次预编译，在这个过程中，首先将变量声明及函数声明提升至当前作用域的顶端，然后进行接下来的处理。

## 2 数据类型

### 2.1 数据类型和数据类型判断

#### 2.1.1 数据类型

　　ES5中包含5种简单数据类型（基本或原始数据类型），一种复杂数据类型Object，ES不支持任何创建自定义类型的机制（C语言中支持创建自定义数据类型）。

- Undefined
- Null
- Boolean
- Number
- String
- Object

#### 2.1.2 数据类型判断

　　在ES中可以使用typeof操作符来对一个变量的数据类型进行判断, typeof返回一个字符串，大致为以下几种。

```js
"undefined" // 这个值未被定义
"boolean"  // 这个值是布尔值
"string"  // 这个值是字符串
"number"  // 这个值是数字
"object" // 这个值是对象或者null
"function"  // 这个值是函数
```

　　typeof是一个操作符不是一个函数，所以在类型判断时候，不需要使用调用运算符，后面直接跟变量或者字面量进行判断即可。

```js
var arrayTets = [1, 2, 3];  // 定义一个数组
var num = 24;  // 定义一个数字

console.log(typeof arrayTets);  // res => object
console.log(typeof num);  // res => number
console.log(typeof 29);  // res => number
console.log(typeof null);  // res => object  , 特殊值null被认为是一个空的对象引用
```

### 2.2 基本数据类型详解

#### 2.2.1 Undefined

　　Undefined类型只有一个值，即特殊的undefined，使用var声明变量时，但并未初始化时，这个变量的值就是undefined。(即在对变量进行声明时变量的默认值会被设置为undefined，而不需要再程序中显式的指定)。

　　一个变量在未声明和未赋值的前提下，直接进行使用的时候会引起错误提示，但是这个变量却可以使用操作符typeof进行类型判断，并返回undefined值。这一点很奇特需要我们多注意，它有一个好处，就是我们在代码中显式的初始化我们声明的每一个变量，那么当一个变量在进行类型判断时，返回undefined，则证明该变量未被声明，也未被初始化。

```js
var name = "system";
console.log(typeof name);  // res => string
console.log(typeof age);  // res => undefined
```

#### 2.2.2 Null

　　Null类型也只有一个值，这个特殊的值为null，null表示一个空的对象引用，所以在使用typeof操作符时，会返回一个对象类型object, 所以一个变量如果想去保存对象而不是原始数据类型，可以显式的将其初始化为null，这样在条件测试中我们就可以判断该值是否被赋值为一个有意义的对象。

```js
// 这里需要注意的是undefined派生自null，所以使用普通的判断时，他两是相等。

if (null == undefined) { // 条件成立
	console.log(true);      
}
```

#### 2.2.3 Boolean

　　Boolean类型包含两个值，分别为true和false， 他们在条件测试中是很有用的，如果要将一个值转换为Boolean类型，可以使用内置函数Boolean()，使用Boolean转换类型的规则如下所以，要牢记，这在条件测试中很有用：

| 序号 | 数据类型  | 转换为true的值 | 转换为false的值 |
| :--: | :-------: | :------------: | :-------------: |
|  1   |  Boolean  |      true      |      false      |
|  2   |  String   | 任何非空字符串 |    空字符串     |
|  3   |  Number   |  任何非零数字  |     0和NaN      |
|  4   |  Object   |    任何对象    |      null       |
|  5   | Undefined |   **不适用**   |    undefined    |

　　在条件测试中一些情况下会自动的调用Boolean函数，得到布尔值，所以一定要牢记上面的表格。

#### 2.2.4 Number

##### 2.2.4.1 数字的表示

　　Number类型用来表示数字和浮点数，通常采用的字面量都是十进制数。保存整数的时候使用32位，保存浮点数的时候使用64位。

```js
var age = 18;
```

　　数字类型也可以表示其他进制的数字。

```js
// 八进制
var num1 = 076; // 通过第一位声明为0,可以表明该字面量为八进制数
var num2 = 078; // 八进制指定0~7表示，如果声明了八进制，但是后面的数字超出了声明的进制范围，则0被省略，字面量被表示为十进制

// 同时应该注意的情况是，严格模式下，是不允许使用八进制进行数字表示的，在严格模式下，八进制无效，会抛出异常
```

```js
// 十六进制
// 字面量开头使用0x表示
var num3 = 0xA;
```

　　在进行数字计算的时候，不同的进制都会转换为十进制进行计算。

　　在进行浮点数保存时，不建议省略小数点前的0，同时应该注意Number类型会自动的将可以保存为整数的浮点数转换为整数进行保存，节省空间。

```js
var num1 = 1;
var num2 = 1.0;

if (num1 == num2) { // 由于num2中的浮点数被自动的转换为整数保存，所以num1和num2的值是相等的
    console.log(true);
}
```

　　对于极大或者极小的数值，可以采用科学计数法进行表示：

```js
var num1 = 3.125e7; // 表示的值为31250000
var num2 = 3.125e-7; // 表示的值为0.0000003125
```

　　由于计算机的硬件限制，在使用浮点数时一定要小心，因为`0.1 +  0.2`这样的表达式，通常不会被计算为0.3，而是会产生误差。

##### 2.2.4.2 数字范围

　　由于内存的限制，数字类型并不能表示世界上的所有数，只能表示一个范围中的数字，通常在浏览器中的Number.MIN_VALUE和Number.MAX_VALUE属性中保存着数字类型可表示的最小值和最大值。

　　某个计算结果如果超出了js表示数字范围的最大范围，则会被转换为一个特殊值Infinity（正无穷）,如果小于最小表示范围则为-Infinity（负无穷）。同时应该注意的是Infinity是不能参与运算的。如果想要查看一个数是否在可表示的范围内可以使用以下函数：

```js
isFinite(num); //返回true，证明该数可以被表示
```

　　在js中使用NaN表示一个非数值的数，避免在程序中抛出异常，如在js中任何数值除以非数值，都会返回NaN值;

```js
console.log(0 / "a"); // res => NaN

// NaN有两个特点
// 1. 涉及到NaN的运算都会返回NaN
// 2. NaN与任何值都不相等，包括他自己， 所以引入isNaN函数来判断一个值是否为NaN

var test = 0 / 0;
console.log(typeof test);  // res => number

if (isNaN(test)) { // isNaN(test) 等于 true
    console.log("this is not a number!");
}

// 由于NaN不是一个数值，所以他也不在数值得可表示范围中，所以使用isFinite也可以判断
if (!isFinite(test)) { // isFinite(test)等于false,!isFinite(test)等于true
    console.log("this is not a number!");
}
```

##### 2.2.4.3 数值转换

　　数值转换的方法主要涉及到Number(),parseInt()和parseFloat()，前一个方法可以将任何类型转换为数值，后两种方法主要针对字符串转换为数值而言。

　　**Number方法转换规则如下所示：**

|   序号    |                             规则                             |
| :-------: | :----------------------------------------------------------: |
|  Boolean  |                    true -> 1 , false -> 0                    |
|  Number   |                           原路输出                           |
|   null    |                              0                               |
| undefined |                             NaN                              |
|  string   |                   规则比较复杂，放在下面说                   |
|  object   | 先调用对象的valueOf方法，然后根据字符串规则去转换，如果结果是NaN,则调用toString方法，再根据字符串规则转换 |

　　Number方法转换字符串的规则如下所示：

1. 字符串中只包含数字，则转换为十进制数 ；（如字符串中是个十六进制的数，直接转换为10进制的数）

2. 字符串只包含浮点数，则转换为对应的浮点数；

3. 如果字符串是空的则转换为0；

4. 如果超出上述范围则准换为NaN

   ```js
   var test = "1222323sldsldlsdl"
   console.log(Number(test)); // res => NaN
   ```

　　**由于Number方法生成规则教为复杂，且对于以数值开头的混合字符串支持的不好，所以有了parseInt方法，该方法的转换规则如下：**

　　首先会忽略字符串前面的空格，直到找到一个非空格的字符，如果第一个字符不是数值或者负号，则返回NaN，如果第一个字符是数值或者负号，则会进行读取一直到下一个符号不为数值为止，然后将读取的符号返回，形成数值。同样，该方法也可以识别八进制和十六进制，并将它们转换为十进制。

```js
var num1 = " 2356235.1asjdkasjdlkasj";
console.log(parseInt(num1)); // res => 2356235
```

　　关于在该方法中解析八进制的能力，是有区别的ES3中可以识别八进制的前导零，而ES5不能识别八进制的前导零；

```js
var num1 = "070";
console.log(parseInt(num1));  // ES5引擎解析为70，ES引擎解析为56（将070按照八进制转换为了十进制数56）

// 基于上述的差异，parseInt方法提供了基数指定参数，让我们在转换的时候，手动明确要转换的原始数据的进制
var num1 = "070";
console.log(parseInt(num1， 8)); // res => 56

// 所以在使用该方法的时候一定要明确的指定解析的基数
parseInt(stringTest， 10);  // 通常情况下10进制用的比较多
```

　　**上面的方法弥补了Number不能解析混合字符串的缺点，但是他无法解析包含浮点数的混合字符串，js中的parseFloat方法，可以解析混合字符串，他会保留第一个小数点，以及之后的数值（当然科学计数法中的e(E)也会被保留），不过该方法无法解析非十进制的数，因为他不识别前导零。**

```js
var num1 = "23123123.1231231assadkasdkaskd";
console.log(parseInt(num1, 10)); // 23123123
console.log(parseFloat(num1));  // 23123123.1231231

var num2 = "0xA";
console.log(parseFloat(num2)); // 0

var num3 = "2323723.32323.32323";
console.log(parseFloat(num3));  // 2323723.32323

var num4 = "3.123E7";
console.log(parseFloat(num4));  // 31230000
```

#### 2.2.5 string

##### 2.2.5.1 字符类型的基本定义

　　String类型用于表示由零个或者多个16位Unicode字符组成的字符序列，即字符串。字符串由`'`和`"`包含。在js中，单引号和双引号并没有实质性的区别。

　　字符类型中包含一些特殊的字面量，称为转义序列，用于表示具有特殊作用的字符（防止转义可以在特殊字符前加`\`进制转义）。

| 序号 | 字面量 |  含义  |
| :--: | :----: | :----: |
|  1   |   \n   |  换行  |
|  2   |   \t   |  制表  |
|  3   |  \\\   |  斜杠  |
|  4   |  \\'   | 单引号 |
|  5   |  \\"   | 双引号 |

　　可以调用字符串的特殊方法，获取字符串的长度。

```js
var test = "aksdhjkasdhjk";
console.log(test.length);
```

　　字符串是不可变的，字符串一旦创建就不能改变他的值，如果发生改变，会销毁原来的字符串，把新的字符串填充到现有变量中。

##### 2.2.5.2 转换为字符串

　　方式一是使用每个对象自身的toString方法，这个方法返回相应值得字符串表现，不过null和undefined没有该方法，可以给toString传参，指定输出的进制。

```js
var test = 19;
console.log(test.toString()); // res => "19"
```

　　方式二使用转换函数String方法，在不确定变量值是否为null和undefined的情况下建议使用该方法。该方法的转换规则如下所示:

- 如果变量包含toString方法，则使用String方法得到的结果相同；
- 如果变量是null ，则返回"null";
- 如果变量是undefined， 则返回"undefined";

### 2.3 自动转换

#### 2.3.1 自动转换规则

　　**js中，在对不同类型数据进行比较的时候遵寻以下原则：**

- 比较字符串和数字时，都将把字符串转换为数字，再对两个数字进行比较；

- 比较布尔值和其他类型，在这种情况下，将把布尔值转换为数字，再进行比较；
- 比较null和undefined，这两个值的比较结果为true；

　　**当在其他运算中出现不同类型的数据操作时，js也可以进行自动转换，如字符串的拼接操作，表达式中的数学运算**

- 将数字和字符串相加，JavaScript将把数字转换为字符串，再进行拼接。这与==运算符的情况大致相反;
- 对于其他算术运算符，如乘法、除法和减法运算符，JavaScript将认为你要执行的是算术运算，而不是字符串运算;

```js
var order = 1 + 2 + " pizzas";
// 结果将为"3 pizzas"，而不是"12 pizzas"。这是因为从左往右计算时，先将1和2相加(因为它们都是数字)，结果为3；接下来，将3与字符串"pizzas"相加，因此将3转换为字符串，再拼接这两个字符串。
```

　　通常比较运算符中的大小比较都是比较数字类型的，但是如果运算符的两边是字符串，如何进行比较？

- "mango"以m打头，而b在字母表中排在m前面，因此"banana"比"mango"小。"mango"比"melon"小，因为虽然它们的第一个字母相同，但比较第二个字母时，发现a排在e的前面。

### 2.4 Object类型

　　对象是一组数据和功能的集合，所谓数据就是对象的属性，所谓功能就是对象的方法。对象可以通过执行new操作符跟要创建的对象类型的名称来创建。

　　Object对象具有如下的属性和方法：

- constructor
  - 保存着用于创建当前对象的函数；
- hasOwnProperty(prepertyName)
  - 用于检查给定的属性在当前的实例对象中是否存在；
- isPrototypeOf(object)
  - 用于检查传入的对象是否是当前对象的原型；
- propertyIsEnumerable(propertyName)
  - 用于检查给定的属性是否能够使用for-in语句；
- toLocaleString()
  - 返回对象的字符串表示，该字符串与执行环境的地区对应；
- toString()
  - 返回对象的字符串表示；
- valueOf()
  - 返回对象的字符串，数值或布尔值表示，通常与toString()方法的返回值相同；

### 1.5 对象

#### 1.5.1 数组

　　如何使用JavaScript表示多个值，数组是一种可存储很多值的JavaScript数据类型。数组可存储的元素数受制于计算机的内存量。定义一个数组的方式如下所示：

```js
// 创建一个空的数组
var arrayTest = [];

// 数组中可以存储不同的数据类型
var arrayTest1 = [1, 2, "hello"];

// 通过构造函数创建一个新的数组
var arrayTest2 = new Array(3); // 创建一个包含三个索引的数组，但是字面量方式创建数组的方式较为常用
```

　　如何访问数组中的元素：

```js
var arrayTest1 = [1, 2, "hello"];

// 通过索引的方式访问数组，js中的数组没有负索引
// 如果一个访问的元素不存在，返回undefined
console.log(arrayTest1[1]) 

// 获取数组的长度arrayTest1.length, 可以结合for循环，遍历数组
for (var i = 0; i < arrayTest1.length-1; i++) {
    console.log(arrayTest1[i])
}

// 向数组中添加一个值
arrayTest1.push("hi")  // 在数组末尾添加一个新元素,类似python中列表的append方法
```

　　数组的稀疏性：

```js
// 首先需要明确的是数组是稀疏的，稀疏数组是有些索引处有值，而其他索引处没有值的数组。

// 以下创建了一个稀疏数组，为数组添加值得时候一定要注意数组的稀疏性
var sparseArray = [];
sparseArray[0] = true;
spraseArray[100] = true;
```

#### 1.5.2 对象

　　访问对象的属性，可以通过句点表示法：

```js
var student = {
    name: "achui",
    age: 18
};

// 为对象添加新的属性
student.gender = "women";

// 访问对象的属性,访问不存在的属性时将得到undefined
student.gender;

// 修改对象的属性值
student.gender = "man";

// 删除属性的值,使用特殊的关键词delete
delete student.gender;

// 访问属性的另一种方式使用方括号进行访问
student["gender"]
```

　　变量在存储对象的时候，实际上存储的是对象的引用，而不是像原始类型那样直接存储实际的值。这对于函数传参来说很有趣，我们了解到，js中传递参数是按照值进行传递的，而保存对象的变量实际上保存的是对象的引用，这时在传递时就会将对象引用的副本传递给形参，这样，实参和形参指向了同一个对象，所以在函数中进行对象的属性操作的时候，是会影响引用他的其他变量的。

　　为对象添加行为：

#### 1.5.3 对象的创建

对象字面量提供了一个便利方式，让你能够在代码中随时随地创建对象，但需

要创建大量对象（如一个出租车车队）时，你不想输入数百个对象字面量，不

是吗？

```js
var student = {
    name: "achui",
    age: 18,
    study: function() {
        console.log("study");
    }
};

// 使用对象的方法
student.study();

// 通过this关键词，在方法中使用对象的属性，它与python中的self是相同的
// this关键词指代的就是当前对象
```



## 3 对象

在一个对象中绑定函数，称为这个对象的方法。

instanceof来确定对象是由哪个构造函数创建的

构造函数自动返回它创建的新对

象。

需要创建少量对象时，适合使用

对象字面量。 

■ 

需要创建大量类似的对象时，适

合使用构造函数。

### 1.3.9 构造函数

构造函数涉及到的关键字主要是`this`, `new`, `function`,有一件事情不能做，

那就是从构造函数中返回值，

因为除非返回的是this，否则

这将导致构造函数不返回它创

建的对象。

```js
// 构造函数名字首字母大写，是js的约定，方便辨别
function Dog(name, age, gender) {
    this.name = name;
    this.age = age;
    this.gender = gender;
    this.sayHello = function() {
      console.log(this.name + " say hello!")  
    };
} 

// 通过new创建新的对象
var huahua = new Dog("huahua", 2, "mu");
huahua.sayHello();
```

但有一件事情不能做，

那就是从构造函数中返回值，

因为除非返回的是this，否则

这将导致构造函数不返回它创

建的对象。





这两种方式都有其用武

之地。需要创建大量包含相同

属性和方法的对象时，构造函

数很有帮助。使用构造函数很

方便，可重用代码，还可确保

对象的一致性。

但有时候，需要创建一次性的

简单对象。在这种情况下，使

用对象字面量显得更简洁、更

具表达力。

## 4 函数

### 4.1 定义一个函数 

#### 4.1.1 函数声明定义

![函数的基本定义](./res/003.png)

> **注意事项**

> - 没有return语句的函数返回undefined；

#### 4.1.2 函数表达式

　　函数表达式没有函数名，没有函数名的函数被称为**匿名函数**，通常用于需要函数引用的地方。如以下通过赋值语句进行定义：

```js
var fly = function(num) {
    for (var i = 0; i < num; i++) {
        console.log("Flying");
    }
};

fly(3);
```

#### 4.1.3 函数声明和函数表达式的区别

1. **运行时的区别：**

　　在分析网页期间（执行任何代码之前），浏览器查找函数声明。找到函数声明时，浏览器创建相应的函数，并将得到的函数引用赋给与函数同名的变量，处理所有的函数声明后，浏览器回到代码开头，开始按从头到尾的顺序，而通过函数表达式创建的函数就像普通表达式一样，包含在语句之内，并不会被浏览器预先加载生成。

　　因为函数声明会被预先加载，所有我们可以不必关注调用函数和定义函数之间的顺序关系（在shell中需要注意，在使用函数前，需要先定义函数，否则报错）

，这种特性使得我们可以将函数声明放在文件的任何地方, 通常将函数声明放置在一起是最佳实践。

2. **赋值时的区别**

　　函数声明是一条语句。可以认为它包含一条隐藏的赋值语句，这条语句将函数引用赋给一个变量。函数表达式不自动将函数引用赋给任何变量，你必须显式地将其进行赋值。

> **注意事项：**

> - 无论是函数声明还是函数表达式，最终都将得到一个函数。但它们之间存在一些重要的差别。一个差别是，使用函数声明时，函数将在执行代码前创建；而使用函数表达式时，函数将在运行阶段执行代码时创建。另一个差别与函数命名相关：使用函数声明时，将创建一个与函数同名的变量，并让它指向函数；而使用函数表达式时，通常不给函数指定名称，因此你要么在代码中将函数赋给一个变量，要么以其他方式使用函数表达式（如传参等）。

### 4.2 函数传参

#### 4.2.1 形参和实参

![形参和实参](./res/004.png)

#### 4.2.2 函数对传入参数的个数和类型的要求

　　js中向函数传递实参，是没有类型限制和数量限制的，对于类型而言，我们可以**传入以下类型**：

- 可通过实参传递任何JavaScript值，如字符串、布尔值或数字;
- 可以将变量作为实参传递;
- 可以将表达式用作实参（如函数表达式）;

　　**对于传递的参数个数js函数会做出以下反应：**

1. ***如果传递的实参太多，结果将如何？***

   在这种情况下，JavaScript将忽略多余的实参。

2. ***如果传入的实参不够，结果将如何？***

   将没有相应实参的形参设置为未定义（undefined）。

#### 4.2.3 argments关键字

　　它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。`arguments`的使用方式类似`Array`但它不是一个`Array`；

```js
function abs() {
    if (arguments.length != 0) {
        for (var i in arguments) {
            console.log(arguments[0]);
        }
    } else {
        console.log("No params!")
    }
}

abs(); // No params!
abs(11); // 11
```

#### 4.2.4 JavaScript按值传递实参

- 向函数传递实参时，首先复制其值，再将这个值赋给相应的形参，按值传递的真正意义在于，在函数中修改形参的值时，只会影响形参，而不会影响传递给函数的变量；
- 对于对象而言，传递的其实是对象的引用，所以在函数内部对对象的属性进行更改的时候，会影响原有对象，因为操作的变量中的引用和实参变量中对象的引用指向同一个对象；

#### 4.2.5 ES6的rest参数

　　rest参数主要是获取多余参数的一种手段，使用rest可以避免在获取多余参数时对arguments的遍历操作。

```js
function testRest(a, b, ...rest) {
    console.log(a + " " + b);
    console.log("-----------------------");
    console.log(rest);
}

testRest();
testRest(3, 4, 5);

undefined undefined      
-----------------------
[]  // 没有多余参数时返回空的数组

3 4
-----------------------
[ 5 ]
```

### 4.3 函数作用域

#### 4.3.1 函数的作用域

- 如果一个变量在函数体内部申明，则该变量的作用域为整个函数体，在函数体外不可引用该变量；
- 如果两个不同的函数各自申明了同一个变量，那么该变量只在各自的函数体内起作用。换句话说，不同函数内部的同名变量互相独立，互不影响；
- 由于JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量，反过来则不行；
- 如果内部函数和外部函数的变量名重名怎么办？JavaScript的函数在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量；

#### 4.3.2 变量提升

前面说过，可以将函数声明放在任何地方（代码的开头、末尾、中间），且可在任何地方调用它们。在代码的任何地方，函数声明创建的函数都是已定义的，这被称为提升（hoisting）。

在代码顶层定义的函数是全局的，而在函数中定义的函数是局部的

在代码顶层定义的函数与在函数中定义的函数之间的唯一差别在于，它们的作用域不同，在函数内部，如果你使用函数声明创建了一个嵌套函数，那么在这个函数的函数体的任何地方，嵌套函数都是已定义的；如果你使用函数表达式创建了一个嵌套函数，则在这个函数的函数体内，仅当函数表达式执行后，嵌套函数才是已定义的。

#### 1.3.4 函数是一等对象

- 将其赋给变量或存储在数组和对象等数据结构中（匿名函数的应用）；

- 将其传递给函数（将函数当做参数进行传递，传递的是指向函数的引用）；

- 从函数中返回它们；

#### 



#### 



#### 1.3.7 嵌套函数

前面我们讲到过，函数在调用完成后消逝，但是其中定义的局部变量会在局部作用域中保留下来

所谓词法作用域，指的是JavaScript的作用域规则完

全基于代码的结构，而不是一些动态的运行阶段属性。这

意味着只需查看代码的结构，就能确定变量是在什么地方

定义的。另外别忘了，在JavaScript中，只有函数会引入新

的作用域。因此，对于在函数中引用的变量，要确定它是

在哪里定义的，可从最里面（当前函数）开始依次向最外

面进行查找，直到找到它为止。如果在这些函数中都找不

到它，则它要么是全局的，要么未定义。

别忘了，JavaScript函数都是在定义它的环境中

执行的。在函数中，要确定变量来自何方，可

按从内到外的顺序依次在包含它的函数中搜索。

#### 1.3.8 闭包

闭包：名词，指的是函数和引用环境。

函数通常包含局部变量（它们

是在函数体中定义的，包括所有的形参），还可能包含不是在本

地定义的变量，这些变量被称为自由变量。自由一词源于这样一

点：在函数体内，自由变量没有绑定到任何值（换而言之，它们

不是在本地声明的）。有了给每个自由变量都提供了值的环境后，

便将函数敲定了；而函数和环境一起被称为闭包。

对于函数体内的变量，如果它既

不是在本地定义的，又不是全局变量，

便可肯定它来自包含当前函数的其他

函数，可从环境中获取其值。

```js
function makeCounter() {
 	var count = 0;
    function counter() {
        count = count + 1;
        return count;
    }
	return counter;
}
```

并非只能通过从函数返回函数来创建闭包。如果函数使用了自由变量，则

每当你在创建该函数的上下文外面执行它时，都将创建一个闭包。

学习闭包时，大家常常错误地认为闭包的环境包含所有变量及其值的副本。实际上不是这样

的。环境引用的是实时变量

函数表达式是在运行阶段与其

他代码一起执行的，因此在函

数表达式所在的语句执行前，

它创建的函数是未定义的。

通常使用闭包来为事件处理程

序捕获状态

## 5 面向对象编程

　　在js中创建自定义对象主要有以下三种方式：

- 通过字面量创建对象，适合创建那些一次性使用的对象；
- 通过构造函数创建对象，适用于批量创建同类型的对象；
- 原型方式创建对象是对构造函数创建对象的一种加强，可以使得每个对象不需要单独保存方法的引用；

　　这里通过《Heard First JavaScript》一书的小狗例子进行说明：

```js
// 建立一个构造函数
function Dog(name, breed, weight) {
    this.name = name;
    this.breed = breed;
    this.weight = weight;
    this.bark = function() {
        if (this.weight > 25) {
            alert(this.name + " says Woof!");
        } else {
            alert(this.name + " says Yip!");
        }
    };
}

// 创建三个狗对象
var fido = new Dog("Fido", "Mixed", 38);
var fluffy = new Dog("Fluffy", "Poodle", 30);
var spot = new Dog("Spot", "Chihuahua", 10);
```

　　上述三个狗对象可抽象为以下图示(通过图示发现，实际运行代码时，方法对象被每个对象所单独保存了指向他的引用，这极大的浪费了内存空间)：

![构造函数的弊端](./res/005.png)

　　为了解决上述问题，以下就引出了原型的概念，我们通过对原型对象的扩展，达到在运行时上对方法的重用，避免每个对象都保存方法的副本，节省内存空间。

### 5.1 原型的概念

#### 5.1.1 原型定义

　　不同于python等语言采用类与实例的方式实现面对对象编程，JavaScript采用的不是基于类的面向对象系统，而是更强大的原型模型，其中的对象可继承和扩展其他对象的行为，在JavaScript中，对象从其他对象那里继承行为，我们称之为**原型式继承**（prototypal inheritance）或基于原型的继承，而被继承的对象称为**原型**。

　　如何通过代码创建原型，通过构造函数的**prototype**属性，该属性是一个指向原型的引用；

```js
// 创建构造函数
function Dog(name, breed, weight) {
     this.name = name;
     this.breed = breed;
     this.weight = weight;
}

// 创建原型
Dog.prototype.species = "Canine";
Dog.prototype.bark = function() {
     if (this.weight > 25) {
     	console.log(this.name + " says Woof!");
     } else {
     	console.log(this.name + " says Yip!");
     }
};
Dog.prototype.run = function() {
 	console.log("Run!");
};
Dog.prototype.wag = function() {
 	console.log("Wag!");
};

// 创建一个Dog对象
var spot = new Dog("Spot", "Chihuahua", 10);

// 重写bark方法，对对象调用方法时，如果在对象中找不到，将在原型中查找它
spot.bark = function() {
 	console.log(this.name + " says WOOF!");
}
```

> **注意事项：**

> - 原型是动态的，给原型添加新的方法或属性后，继承该原型的所有对象实例都将立即看到它；
> - 修改原型的任何属性时，都将影响继承该原型的所有对象——只要它们没有重写这个属性；
> - 对象实例中如果对原型中同名的属性或者方法进行了修改操作，则认为在实例对象中重写了该属性或方法；

#### 5.1.2 判断属性在原型还是在对象实例中

　　可使用每个对象都有的方法hasOwnProperty。如果属性是在对象实例中定义的，这个方法将返回true，hasOwnProperty方法来自于Object对象。

### 5.2 原型链

　　在JavaScript中，可建立供对象继承的原型链（可以理解为python中的继承树，只不过js是单继承的），原型链原理如下所示：

![原型链原理](./res/006.png)

接着原型中的狗对象，我们创建图示的原型链：

```js
// 狗类在5.1中
function ShowDog(name, breed, weight, handler) {
     Dog.call(this, name, breed, weight);
     this.handler = handler;
}

ShowDog.prototype = new Dog();
ShowDog.prototype.constructor = ShowDog;
Showdog.prototype.league = "Webville";
ShowDog.prototype.stack = function() { 
	console.log("Stack");
};
ShowDog.prototype.bait = function() {
	console.log("Bait");
};
ShowDog.prototype.gait = function(kind) {
	console.log(kind + "ing");
};
ShowDog.prototype.groom = function() {
	console.log("Groom");
};

var scotty = new ShowDog("Scotty", "Scottish Terrier", 15, "Cookie");
```

**创建的每个原型链的终点都是Object**



不可重写

千万不要重写Object的如下属性：

可以重写

熟悉原型并知道如何安全地重写属性后，就可以重写Object的

如下属性了：

不可重写部分

**constructor**

**hasOwnProperty**

**isPrototypeOf**

**propertyIsEnumerable**



可重写部分

**toString**

**toLocaleString**

**valueOf**